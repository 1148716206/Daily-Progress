<h1>22/1/12每日一题</h1>

> 1、CSS篇：定位中，absolute 与 fixed 共同点与不同点
> 2、JavaScript篇：闭包的概念及特点
> 3、算法：说一下递归和迭代的区别是什么，各有什么优缺点？
> 4、力扣101.对称二叉树：给你一个二叉树的根节点root，检查它是否轴对称。

<h1>1、CSS: 定位中，absolute与fixed有什么区别</h1>

相同点：

- 使元素**脱离文档流**，不占据位置，**触发BFC**
- 改变行内元素的呈现方式，将display变为inline-block
- **覆盖非定位的文档元素**

不同点：

- absolute是绝对定位，其根元素可以设置，fixed是固定定位，根元素是浏览器
- 当页面有滚动条时，absolute会跟着父元素移动，fixed固定在页面的具体位置
- absolute是相对于离它最近的有相位定位的父元素进行定位（子绝父相），如果没有则根据浏览器窗口；fixed是相对于浏览器窗口定位

<h1>2、JavaScript：闭包的概念及特点</h1>

1、概念

（1）红宝书：闭包是指有权访问另一个函数作用域中的变量的函数

（2）形式上：函数内部返回一个函数

（3）本质：返回出去的函数，对它父级作用域中的变量存在引用，没有被垃圾回收机制回收

2、闭包的作用及应用场景

（1）私有化变量和方法

​			优点：

​					让**外部访问函数内部变量**成为可能

​					避免使用全局变量，防止**全局变量污染**

​             缺点：

​					可能导致**内存溢出**

```
var obj = {}
for(var i = 0; i < 100000; i++) {
	obj[i] = new Array(1000000)
	console.log('11111')
}
```

​					可能会导致**内存泄漏**

```
function fn1() {
	var arr = new Array[1000000]
	function fn2() {
		console.log(arr.length)
	}
	return fn2
}
var f = fn1()
f()  //闭包导致变量arr不会被回收
```

**内存泄漏**：变量一直占据内存空间，不会被垃圾回收机制回收，导致不能访问该内存（不可达）

**及时释放**：定时器清空（null），不要滥用闭包，尽量不要声明全局变量

**应用场景**：防抖节流函数，回调函数

3、垃圾回收：

- 循环计数
- 标记清楚

<h1>3、算法：递归和迭代的区别，以及优缺点</h1>

（一）、定义

- 递归：递归常备用来描述以自相似的方法重复事物的过程，**函数定义中使用函数自身的方法**；递归实际上不断地调用函数，直到函数有返回值，才逐层返回，递归是用栈机制实现的。

  > 简单来说：<font color='red'>程序调用自身</font>称为递归

- 迭代：是重复反馈过程的活动，其目的通常是为了接近并达到所需的目标或结果。每一次对过程的重复调用被称为一次"迭代"，而每一次迭代得到的结果都会被作为下一次迭代的初始值。迭代是顺序的，不设计调用栈操作，前面的代码不会被后面代码影响。

  > 简单来说：<font color='red'>利用变量的原值推出新值</font>称为迭代

（二）、异同

- 相同点：都属于循环

-  不同点：

  - <font color='orange'>程序结构不同</font>：递归是重复调用自身函数实现循环，迭代是函数内部代码实现循环，且每次循环的代码作为下次循环的初始值。

  - <font color="orange">算法结束的方式不同</font>： 递归：需要结束条件，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。

  - <font color="orange">效率不同</font>：**在循环次数较大时，迭代效率明显高于递归**

  - <font color="orange">运行过程不同：</font> 如果是迭代，整个就在主函数或调用函数的栈空间中；递归则是不断申请函数调用的占空间，在计算过程中，计算一个结果，退出一层栈；递归过程是在调用时可能会出现栈溢出。

  - 理论上递归和迭代的时间复杂度方面是一样的，但是**实际应用中（函数调用和函数调用堆栈的开销）递归比迭代效率低**。

    

（三）、优缺点

- 递归：
  - 优点：大问题转化为小问题，减少代码量，可读性好
  - 缺点：递归调用浪费空间（递归调用栈），可能会造成栈溢出

- 递归：
  - 优点：代码运行效果好，时间只因循环次数增加而增加，没有额外的空间开销
  - 缺点：代码不如递归简洁

<h1>4、力扣101.对称二叉树</h1>



![二叉树](https://raw.githubusercontent.com/1148716206/Blog-Picture/master/101%E4%BA%8C%E5%8F%89%E6%A0%91.png)

- DFS深搜递归

  ```
  var isSymmetric = function (root) {
  	//先dfs深搜到最下面，验证局部对称性
  	function dfs(left, right) {
  		// 遍历到叶节点，返回true
  		if(left === null && right === null) {
  			return true
  		}
  		//遍历到只有一个子节点的节点，返回false
  		if(left === null || right === null) {
  			return false
  		}
  		 //遍历到两个不相等的节点，返回false
  		 if(left.val !== right.val) {
  		 	return false
  		 }
  		 //递归比较左节点的左孩子和右节点的右孩子&&左节点的右孩子和右节点的左孩子
  		 return dfs(left.left, right.right) && dfs(left.right, right.left)
  	}
  	return dfs(root.left, root.right)
  }
  ```

  

- 队列+迭代

  ```
  var isSymmetric = function(root) {
  	//迭代方法是判断是否为对称二叉树
  	//首先判断root是否为空
  	if(root !== null) return true
  	let quere = []
  	queue.push(root.left)
  	queue.push(root.right)
  	while(queue.length) {
  		let leftNode = queue.shift() //左节点
  		let rightNode = queue.shift() //右节点
  		if(leftNode === null && rightNode === null) {
  			continue
  		}
  		if(leftNode === null || rightNode === null || leftNode.val !== rightNode.val) {
  		return false
  		}
  		queue.push(leftNode.left) //左节点左孩子入队
  		queue.push(rightNode.right) //右节点右孩子入队
  		queue.push(leftNode.right) //左节点右孩子入队
  		queue.push(rightNode.left) //右节点左孩子入队
  	}
  }
  ```

- 栈 +迭代

  ```
  var isSymmetric = function(root) {
  	if(root === null) return true
  	let stack = []
  	stack.push(root.left) 
  	stack.push(root.right)
  	while(stack.length) {
  		let rightNode = stack.pop() //右节点
  		left leftNode = stack.pop() //左节点
  		if(leftNode === null && rightNode === null) {
  			continue
  		}
  		if(leftNode === null || rightNode === null || leftNode.val !== rightNode.val) {
  		return false
  		}
  		stack.push(leftNode.left) //左节点左孩子入队
  		stack.push(rightNode.right) //右节点右孩子入队
  		stack.push(leftNode.right) //左节点右孩子入队
  		stack.push(rightNode.left) //右节点左孩子入队
  	}
  	return tru
  }
  ```

  